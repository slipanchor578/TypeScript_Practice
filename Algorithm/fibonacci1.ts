function fibonacci1(n: number): number
{
	if(n < 1)
	{
		return 0;
	}
	else if(n == 1)
	{
		return 1;
	}

	// フィボナッチ数(n) = フィボナッチ数(n-1) + フィボナッチ数(n-2)を利用して再帰
	return fibonacci1(n - 1) + fibonacci1(n - 2);
}

// 保存先として配列を使う
// fib(0) = 0, fib(1) = 1 は決まっているので入れておく
const arr = [0,1];

function fibonacci2(n: number): number
{
	// JSでは配列内の初期化していない要素にアクセスした場合、undefinedが返ってくることを利用する
	if(arr[n] == undefined)
	{
		// 再帰しつつ、かつn番目の結果がまだ求められていない場合は計算して配列に保存しておく
		// 例えば「fibonacci2(2)」の場合は「fib2(2 - 1)」と「fib2(2 - 2)」の戻り値を使い
		// arr[2] = arr[1] + arr[0] = 1 + 0 = 「1」となる
		arr[n] = fibonacci2(n - 1) + fibonacci2(n - 2);
	}

	// いきなり「fib2(10)」の結果は求められないが、nを減らしつつ再帰を繰り返していくうちにarr配列にarr[2] = 1, arr[3] = 2, arr[4] = 3 のように
	// 答えが溜まっていく。既に求めているnについては配列から取り出せるので同じフィボナッチ数の計算をしなくて済むので圧倒的に早くなる
	return arr[n];
}

// fibonacci1にn=50を渡すと10分くらい応答が帰ってこない
// fibonacci2なら一瞬で返ってくる
const result1 = fibonacci1(parseInt(process.argv[2]));
const result2 = fibonacci2(parseInt(process.argv[2]));

console.log(result1);
console.log(result2);

/*
	最初は0、次が1、3番目以降は直前の2つの数字を足したものになる数列をフィボナッチ数列という

	0 1 1 2 3 5 8 13 21 34

	上のプログラムはフィボナッチ数のn番目を求めるプログラム
	F0 = 0
	F1 = 1
	Fi = Fi - 1 + Fi - 2 (i >= 2)
	のように決まっているので、楽に再帰関数に落とし込める

	が、このままだとnが大きくなるに連れて処理に時間がかかり最悪全く反応しなくなる
	例えばfibonacci(4)の時答えは「3」だがこの計算には

	F4	=>	F3	=>	F2	=>	F1
			+		+		+
					F1		F0
			+
			F2	=>	F1
					+
					F0
	
	個の計算を必要とする。最終的に上段のF2 => (F1 + F0) の分解される所で「１」
	上段のF3 => (F2 + F1)と分解される所のF2を除くF1の所で「1」
	下段のF2 => (F1 + F0)と分解される所で「1」となり、合わせて「3」になる

	図を見ると同じ「fibonacci(2)」を2回計算していることが分かる
	このようにnが大きくなるほど、同じ計算を新しく何回も繰り返してプログラムの処理が遅くなる
	よって1度計算した結果は保存しておけば良い

	fib2の方は余裕でn = 1000 を計算できる。n = 1500の時にnumber型に格納できる値の範囲を超えてInfinityとなる
	n = 9000の時にプログラム自体のスタックがオーバーフローしてしまった
	おそらく再帰しすぎだと思われる
*/