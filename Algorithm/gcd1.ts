function gcd1(num1: number, num2: number): number
{
	// 小さい方で割っていく
	let diviser = Math.min(num1, num2);

	while(diviser != 0)
	{
		if(num1 % diviser == 0 && num2 % diviser == 0)
		{
			return diviser;
		}
		
		// 1ずつ小さくする
		diviser--;
	}

	// 無い時は1が最大公約数
	return 1;
}

// ユークリッドの互除法を使った場合
function gcd2(num1: number, num2: number): number
{
	// aをbで割った余りをrとする
	const r = Math.floor(num1 % num2);

	// 例えばgcd2(4, 2)のような場合、4 % 2 = 0 となるのでそれが答え
	// gcd2(100, 1)のような場合も同様。100 % 1 = 0
	if(r == 0)
	{
		return num2;
	}

	// 片方の数値が0の場合の対策
	// もし「100 % 0」等とした場合rにはNaNが入るので、これで判定する
	// 仮に「0 % 100」をした場合は、次にgcd2(100, 0)を再帰で呼ぶので「100 % 0」となりこのブロックに入る
	// 「num1とnum2のどちらが0」という判定は必要ない
	if(Number.isNaN(r))
	{
		// 0でない数字が最大公約数
		return Math.max(num1, num2);
	}

	// 駄目ならnum2とrを渡して再びgcd2を呼ぶ
	return gcd2(num2, r);
}

console.log(gcd2(19, 10));
console.log(gcd2(100, 0));

/*
	単純な最大公約数の求め方
	渡された2つの数のうち小さい方をdiviserとして取得する
	2つの数をdiviserで割った剰余を求め、これがどちらも0になる時が最大公約数
	見つからなかった場合はdiviser--して、0になるまで剰余を取り続ける
	それでも見つからなかった場合は1が最大公約数の場合なので1を返す

	この方法は問題があり「gcd1(10, 19)」のような最大公約数が1となる問題の時に
	whileループを「小さい方の整数 - 1」回繰り返してしまう
	なので「ユークリッドの互除法」というアルゴリズムを使う

	まず2つの整数aとbがある
	aをbで割った剰余をrとする
	aとbの最大公約数 = bとrの最大公約数となり、r = 0 の時の除数が最大公約数になる
	違った場合は、今度はa = b, b = r にして再帰で呼び出す
	というもの

	gcd2(10, 19)の場合

	1回目 gcd2(10, 19)
	2回目 gcd2(19, 10)
	3回目 gcd2(10, 9)
	4回目 gcd2(9, 1) (ここで終わり)

	たった4回のループで終わる

	ループの内容もgcd1の方は毎回diveserをデクリメントしつつ
	num1とnum2をdiviserで割ってどちらも余りが0であるかを確認する手間がある

	gcd2の方はnum1をnum2で割った剰余を取った後、駄目ならnum2とrを引数にして
	再びgcd2(num2, r)を呼ぶだけ

	ちょっと凄い所はgcd2でnum1, num2に入る実引数を
	大きい順番に渡す必要がないということ

	例えば

	gcd2(19, 10);
	int r = 19 % 10; // 9
	gcd2(10, 9)

	gcd2(10, 19); // 誤って小さい方から渡す
	int r = 10 % 19; // 10
	return gcd2(19, 10) // ひっくり返って正しく呼べるようになる

	実引数は大きい順に渡した方が判定の回数が1回減るが、何も考えずに渡してnum1の方に小さい数字が入ったとしても
	アルゴリズムの中でひっくり返って再帰で呼び出してくれる

	ちなみに「Xと0の最大公約数」はもれなくXになる
*/